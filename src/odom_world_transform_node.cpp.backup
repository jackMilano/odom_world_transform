// Il nodo crea ed aggiorna la trasformata tra 'world' e 'odom'.

// Libraries
// ROS library
#include "ros/ros.h"

// ROS messages
#include <message_filters/subscriber.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <message_filters/synchronizer.h>

#include "nav_msgs/Odometry.h"
#include "projected_game_msgs/Pose2DStamped.h" // world's robot position

// TF libraries
#include <tf/tf.h>
#include <tf/transform_broadcaster.h>

// Defines
#define UPDATE_PERIOD 2.0 // Every 'UPDATE_PERIOD' seconds we update the transform
#define MIN_CONFIDENCE 0.2f

// Typedefs and Enums
// 'ApproximateTime' policy uses an adaptive algorithm to match messages based on their timestamp.
// XXX: attenzione sta venendo utilizzata la politica 'ApproximateTime'.
typedef message_filters::sync_policies::ApproximateTime<projected_game_msgs::Pose2DStamped, nav_msgs::Odometry> MySyncPolicy;

// Global variables
bool first_boot;
const ros::Duration update_period(UPDATE_PERIOD);
ros::Time last_update_time;
tf::Transform last_transform;


void publishWorldOdomTransformCb(
    const projected_game_msgs::Pose2DStamped::ConstPtr& pose_2d_stamped,
    const nav_msgs::Odometry::ConstPtr& odometry)
{
  static tf::TransformBroadcaster transform_broadcaster;

  ROS_INFO("Sono entrato nella callback di 'publishWorldOdomTransformCb'.");

  // Aggiorniamo la trasformata se:
  // - è passato abbastanza tempo
  // - la confidenza è abbastanza alta
  const ros::Duration time_spent = ros::Time::now() - last_update_time;
  if( (time_spent >= update_period /*&& pose_2d_stamped->confidence > MIN_CONFIDENCE*/) || first_boot )
  {

    ROS_INFO("Aggiornamento della trasformata.");

    first_boot = false; // We need to initialize 'last_transform' at least once.

    // La differenza tra la posa del robot in 'world' e la posa del robot in 'odom'
    //  corrisponde (teoricamente) alla differenza tra le origini dei due sistemi
    //  di riferimenti.
    tf::Transform transform;

    const float offset_x = odometry->pose.pose.position.x - pose_2d_stamped->pose.x;
    const float offset_y = odometry->pose.pose.position.y - pose_2d_stamped->pose.y;
    //const float offset_z = odometry->pose.pose.position.z - pose_2d_stamped->pose.z;
    // Viene settata la posizione del sistema di riferimento 'odom'
    //  rispetto al sistema di riferimento 'world'.
    transform.setOrigin( tf::Vector3(offset_x, offset_y, 0.0) );

    //FIXME: per il momento la rotazione è ignorata
    //tf::Quaternion quaternion;
    //XXX: questo theta ha senso?
    //quaternion.setRPY(0, 0, odometry->pose.pose.orientation. - pose_2d_stamped->theta);
    // Viene settato l'orientamento del sistema di riferimento 'odom'
    //  rispetto al sistema di riferimento 'world'.
    //transform.setRotation(quaternion);

    last_transform = transform;

    // Azzeriamo la variabile 'time_spent'.
    last_update_time = ros::Time::now();
  }

  // Broadcast della trasformata.
  try
  {
    tf::StampedTransform stamped_transform = tf::StampedTransform(last_transform, ros::Time::now(), "world", "odom");
    transform_broadcaster.sendTransform(stamped_transform);
    ROS_INFO("Teoricamente è appena stata inviata la 'stamped_transform'.");
  }
  catch(const tf::TransformException& tf_ex)
  {
    ROS_ERROR("%s", tf_ex.what());
    ros::Duration(1.0).sleep();
  }
  catch(const std::exception& ex)
  {
    ROS_ERROR("%s", ex.what());
    ros::Duration(1.0).sleep();
  }

  return;
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "odom_world_transform_node");
  if(argc!=1)
  {
    ROS_WARN("need no arguments!");
  }
  ROS_INFO("odom_world_transform_node has started");
  ros::NodeHandle node_handle;

  first_boot = true;
  last_update_time = ros::Time::now();

  // Sincronizzazione tra 2 canali di ingresso
  // - la posa 2d del robot restituita dal tracking visuale
  // - l'odometria del robot stesso
  message_filters::Subscriber<projected_game_msgs::Pose2DStamped> pose_2d_sub(node_handle, "robot_2d_pose", 1);
  message_filters::Subscriber<nav_msgs::Odometry> odom_sub(node_handle, "robot_odom", 1);
  message_filters::Synchronizer<MySyncPolicy> sync(MySyncPolicy(10), pose_2d_sub, odom_sub);

  sync.registerCallback( boost::bind(&publishWorldOdomTransformCb, _1, _2) );

  sleep(3); //sleep 3 seconds.

  // 'ros::Rate' makes a best effort at mantaining a particular rate for a loop
  //  WARNING: pay attention to the rate
  ros::Rate loop_rate(30);
  ros::spin();

  return 0;
}
